"""pandoc filters used in converting markdown cells to latex.
Usage in jinja template:

    convert_pandoc('markdown', 'json') | ipypandoc(at_notation=True) | convert_pandoc('json','latex')  # noqa: E501

initially adapted from nbconvert/filters/filter_links.py

Other sources of information:

- [Pandoc User Guide](https://pandoc.org/MANUAL.html#citations)
- [List of Pandoc Elements](https://metacpan.org/pod/Pandoc::Elements)
- [reStructuredText Primer](http://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html)
- [reStructuredText Directives](http://docutils.sourceforge.net/docs/ref/rst/directives.html#figure)
- [sphinxcontrib-bibtex](https://sphinxcontrib-bibtex.readthedocs.io/en/latest/usage.html)


NOTE could use panflute, for more pythonic API, however,
it only supports ``pandoc >= 1.17``

"""

import re
import sys
import json
import warnings
import subprocess
from io import TextIOWrapper, BytesIO

from six import string_types
from distutils.util import strtobool
from distutils.version import LooseVersion
from pandocfilters import (walk,  # noqa: F401
                           RawInline, Math, Image, Table, RawBlock)

# TODO at present we defer import, so we can monkey patch stdin during tests
# from pandocxnos import (elt, PandocAttributes,
#                         attach_attrs_factory, detach_attrs_factory,
#                         extract_attrs)

# from nbconvert.filters import convert_pandoc
from nbconvert.utils.pandoc import (get_pandoc_version, check_pandoc_version,
                                    cast_bytes)

if sys.version_info > (3,):
    from urllib.request import unquote  # pylint: disable=no-name-in-module
else:
    from urllib import unquote  # pylint: disable=no-name-in-module


LATEX_FIG_LABELLED = """\\begin{{figure}}[{options}]
\\hypertarget{{{label}}}{{%
\\begin{{center}}
\\adjustimage{{max size={{0.9\\linewidth}}{{0.9\\paperheight}},{size}}}{{{path}}}
\\end{{center}}
\\caption{{{caption}}}\\label{{{label}}}
}}
\\end{{figure}}"""  # noqa: E501

LATEX_FIG_UNLABELLED = """\\begin{{figure}}[{options}]
\\begin{{center}}
\\adjustimage{{max size={{0.9\\linewidth}}{{0.9\\paperheight}},{size}}}{{{path}}}
\\end{{center}}
\\caption{{{caption}}}
\\end{{figure}}"""  # noqa: E501


def convert_pandoc(source, fmt, to, extra_args=None, encoding='utf-8',
                   allow_stderr=False):
    """Convert an input string using pandoc.

    Pandoc converts an input string `from` a format `to` a target format.

    This is copied from nbconvert, but raises an exception if pandoc fails,
    rather than failing silently

    Parameters
    ----------
    source : string
      Input string, assumed to be valid format `from`.
    fmt : string
      The name of the input format (markdown, etc.)
    to : string
      The name of the output format (html, etc.)

    Returns
    -------
    out : unicode
      Output as returned by pandoc.

    Raises
    ------
    PandocMissing
      If pandoc is not installed.
    RunTimeError
      If allow_stderr=False and stderr returned from pandoc is not empty

    Any error messages generated by pandoc are printed to stderr.

    """
    cmd = ['pandoc', '-f', fmt, '-t', to]
    if extra_args:
        cmd.extend(extra_args)

    # this will raise an exception that will pop us out of here
    check_pandoc_version()

    # we can safely continue
    p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    stdout, stderr = p.communicate(cast_bytes(source, encoding))
    stdout = TextIOWrapper(BytesIO(stdout), encoding, 'replace').read()
    stderr = TextIOWrapper(BytesIO(stderr), encoding, 'replace').read()
    if stderr:
        raise RuntimeError("pandoc run failed: {}".format(stderr))

    return stdout.rstrip('\n')


def compare_version(target, comparison):
    """Set docstring here.

    Parameters
    ----------
    target: str
        target version of pandoc
    comparison: str
        one of '>', '<', '<=', '>=', '=='

    Returns
    -------

    """
    # from pandocxnos import init as get_pandoc_version
    version = LooseVersion(get_pandoc_version())
    required = LooseVersion(target)
    if comparison == ">=":
        return version >= required
    elif comparison == "<=":
        return version <= required
    elif comparison == ">":
        return version > required
    elif comparison == "<":
        return version < required
    elif comparison == "==":
        return version == required
    else:
        raise ValueError("comparison not recognised: {}".format(comparison))


def get_api_version(source_json, as_str=True):
    """
    return None if not found
    if as_str=True return '1.2.3' else return [1, 2, 3]
    """
    # TODO is there a better way to get the pandoc-api-version
    api_version = None
    if compare_version('1.18', '>='):
        try:
            api_version = source_json.get("pandoc-api-version", None)
        except Exception as err:
            warnings.warn("could not extract pandoc-api-version "
                          "from source: {}".format(err))

    if api_version is not None and as_str:
        return ".".join([str(i) for i in api_version])
    return api_version


def traverse_meta(meta, keypath, return_missing=(None, None),
                  assert_type=None):
    """traverse pandoc json meta 

    Parameters
    ----------
    meta: dict
    keypath: list
        path to traverse. if the last key is an integer, 
        then return that index of a "MetaInlines"
    return_missing=None: 
        what to return if the keypath is not found
    assert_type=None: str or None
        if not None, assert the returned object has a particular pandoc type

    Returns
    -------
    pvalue
    ptype: str

    """
    final_index = None
    if isinstance(keypath[-1], int):
        final_index = keypath.pop(-1)

    for i, key in enumerate(keypath):
        if not isinstance(key, string_types):
            raise TypeError("key must be a string: {}".format(key))
        if i == 0 and key not in meta:
            return return_missing
        elif i != 0 and meta["t"] != "MetaMap":
            return return_missing
        elif i != 0 and key not in meta["c"]:
            return return_missing

        if i == 0:
            meta = meta[key]
        else:
            meta = meta["c"][key]

    if final_index is not None:
        if meta["t"] != "MetaInlines":
            return return_missing
        meta = meta["c"][final_index]

    if assert_type is not None and assert_type != meta["t"]:
        raise ValueError(
            "the metadata from {0} is {1} instead of {2}".format(
                keypath, meta["t"], assert_type
            ))

    return meta["c"], meta["t"]


def jinja_filter(source, to_format, from_format="markdown",
                 extra_args=None,
                 at_notation=True, reftag="cref", use_numref=True):
    """run a set of ipypublish pandoc filters as a Jinja2 filter

    We convert the source to an intermediary pandoc-json format,
    run the pandocfilters, then convert to the to_format

    Parameters
    ----------
    source: str
        content to convert
    from_format: str
        format of source
    to_format: str
        format of output
    extra_args: list[str]
        extra arguments to parse to pandoc
    at_notation: bool
        interpret @label as a reference type based on its prefix modifier,
        latex: '' = cite '+' = cref,    '^' = Cref,    '!' = ref,  '=' = eqref
        rst: '' = :cite: '+' = :numref: '^' = :numref: '!' = :ref: '=' = :eq:
        also works with multi labels, e.g. ![@{ref1,ref2}]
    reftag: str
        latex tag for references, when converting [](#label) -> \\ref{label}
    use_numref: bool
        whether to use the ``:numref:`` directive or just ``:ref:``

    Notes
    -----

    if ``at_notation``, ``reftag``, ``use_numref`` set in the source metadata,
    under key ``ipub``, this will preferentially be used.
    See https://pandoc.org/MANUAL.html#metadata-blocks, e.g.

    ```yaml
    ---
    ipub:
        use_numref: True
    ---
    ```

    ``:numref:`` requires ``numfig = True`` in conf.py and,
    for section numbering, a toc tree with ``:numbered:``

    """
    # convert to pandoc's JSON structure
    jsonstr = convert_pandoc(source, from_format, 'json',
                             extra_args=extra_args)
    doc = json.loads(jsonstr)

    # extract metadata
    if 'meta' in doc:
        meta = doc['meta']
    elif doc[0]:  # old API
        meta = doc[0]['unMeta']
    else:
        meta = {}

    # if the ipypublish options are not already in the metadata add them
    meta.setdefault("ipub", {"t": "MetaMap", "c": {}})
    meta["ipub"]["c"].setdefault(
        "use_numref", {"t": "MetaBool", "c": use_numref})
    meta["ipub"]["c"].setdefault(
        "at_notation", {"t": "MetaBool", "c": at_notation})
    meta["ipub"]["c"].setdefault(
        "reftag", {"t": "MetaInlines",
                   "c": [{"t": "Str", "c": reftag}]})
    if get_api_version(doc) is not None:
        meta["ipub"]["c"].setdefault(
            "pandoc_api", {
                "t": "MetaInlines",
                "c": [{"t": "Str",
                       "c": get_api_version(doc)}]})

    # gather all required filters
    filters = gather_all_filters()

    # Walk through the JSON structure and apply filters
    for flter in filters:
        doc = walk(doc, flter, to_format, meta)

    return convert_pandoc(json.dumps(doc), 'json', to_format)


def gather_all_filters():
    """see jinja_filter """
    from pandocxnos import (elt,
                            attach_attrs_factory, detach_attrs_factory)

    global Image
    if compare_version('1.16', '<'):
        Image = elt('Image', 2)

    filters = []

    # replace latex tags with rst
    filters.append(latex2rst)

    # resolve references
    filters.append(resolve_references)
    # resolve math
    filters.extend([
        attach_attrs_factory(Math, allow_space=True),
        resolve_math,
        detach_attrs_factory(Math),
    ])

    # resolve images
    if compare_version('1.16', '>='):
        filters.append(resolve_figures)
    else:
        filters.extend([
            attach_attrs_factory(Image,
                                 extract_attrs=_extract_image_attrs),
            resolve_figures,
            detach_attrs_factory(Image)
        ])

    # resolve tables
    filters.extend([
        attach_attrs_table,
        resolve_tables,
        detach_attrs_factory(Table),
    ])

    return filters


# TODO sphinx directives (like todo, warning etc...) to latex


def latex2rst(key, value, fmt, meta):
    """attempt to replace latex tags with rst directives"""

    if fmt != "rst":
        return None

    use_numref, _ = traverse_meta(meta, ["ipub", "use_numref"],
                                  assert_type="MetaBool")
    numref = "numref" if use_numref else "ref"

    if ((key == 'RawInline' or key == 'RawBlock') and
            (value[0] == 'tex' or value[0] == 'latex')):

        match_noopts = re.match(
            r"^\s*\\([^\{\[]+)\{([^\}]+)\}\s*$", value[1])
        if match_noopts:
            tag = match_noopts.group(1)
            label = match_noopts.group(2)
            rst_dir = {"cref": ":{numref}:`{label}`",
                       "Cref": ":{numref}:`{label}`",
                       "ref": ":ref:`{label}`",
                       "cite": " :cite:`{label}` ",
                       "todo": "\n\n.. todo:: {label}\n\n",
                       }.get(tag, None)
            if rst_dir:
                if key == 'RawInline':
                    return RawInline(
                        'rst', rst_dir.format(label=label, numref=numref))
                else:
                    return RawBlock(
                        'rst', rst_dir.format(label=label, numref=numref))

        match_wopts = re.match(
            r"^\s*\\([^\{\[]+)\[([^\]]*)\]\{([^\}]+)\}\s*$", value[1])
        if match_wopts:
            tag = match_wopts.group(1)
            options = match_wopts.group(2)
            label = match_wopts.group(3)
            rst_dir = {
                "todo": "\n\n.. todo:: {label}\n\n",
            }.get(tag, None)
            if rst_dir:
                if key == 'RawInline':
                    return RawInline(
                        'rst',
                        rst_dir.format(label=label, options=options))
                else:
                    return RawBlock(
                        'rst',
                        rst_dir.format(label=label, options=options))


def _sanitize_label(label):
    """from pandoc documentation
    The citation key must begin with a letter, digit, or _,
    and may contain alphanumerics, _,
    and internal punctuation characters (:.#$%&-+?<>~/)
    """
    label = str(label).lower()
    label = re.sub("[^a-zA-Z0-9-:\\.]+", "", label)
    # TODO raise warning if changed?
    return label


def _extract_image_attrs(x, n):
    """Extracts attributes for an image.  n is the index where the
    attributes begin.  Extracted elements are deleted from the element
    list x.  Attrs are returned in pandoc format.
    """
    from pandocxnos import extract_attrs, PandocAttributes
    try:
        return extract_attrs(x, n)

    except (ValueError, IndexError):

        if compare_version('1.16', '<'):
            # Look for attributes attached to the image path, as occurs with
            # image references for pandoc < 1.16 (pandoc-fignos Issue #14).
            # See http://pandoc.org/MANUAL.html#images for the syntax.
            # Note: This code does not handle the "optional title" for
            # image references (search for link_attributes in pandoc's docs).
            assert x[n-1]['t'] == 'Image'
            image = x[n-1]
            s = image['c'][-1][0]
            if '%20%7B' in s:
                path = s[:s.index('%20%7B')]
                attrs = unquote(s[s.index('%7B'):])
                image['c'][-1][0] = path  # Remove attr string from the path
                return PandocAttributes(attrs.strip(), 'markdown').to_pandoc()
        raise


def attach_attrs_table(key, value, fmt, meta):
    """Extracts attributes and attaches them to element.

    We can't use attach_attrs_factory() because Table is a block-level element
    """
    from pandocxnos import extract_attrs
    if key in ['Table']:
        assert len(value) == 5
        caption = value[0]  # caption, align, x, head, body

        # Set n to the index where the attributes start
        n = 0
        while n < len(caption) and not \
                (caption[n]['t'] == 'Str' and caption[n]['c'].startswith('{')):
            n += 1

        try:
            attrs = extract_attrs(caption, n)
            value.insert(0, attrs)
        except (ValueError, IndexError):
            pass


def resolve_references(key, value, fmt, meta):
    """ identifies hyperlinks in the
    document and transforms them into valid LaTeX tags or rst directives
    calls so that linking to headers between cells is possible.

    if meta["ipub"]["at_notation"] = True, then
    interpret @label as a reference type based on its prefix modifier:

    - latex: '' = cite '+' = cref,    '^' = Cref,    '!' = ref,  '=' = eqref
    - rst: '' = :cite: '+' = :numref: '^' = :numref: '!' = :ref: '=' = :eq:

    also works with multi labels, e.g. ![@{ref1,ref2}]

    Parameters
    ----------
    key: str
        the type of the pandoc object (e.g. 'Str', 'Para')
    value:
        the contents of the object (e.g. a string for 'Str', a list of
        inline elements for 'Para')
    fmt: str
        is the target output format (as supplied by the
        `format` argument of `walk`)
    meta:
        is the document's metadata

    Returns
    -------
    pandoc_object:

    """
    use_at_notation, _ = traverse_meta(meta, ["ipub", "at_notation"],
                                       assert_type="MetaBool")
    use_numref, _ = traverse_meta(meta, ["ipub", "use_numref"],
                                  assert_type="MetaBool")
    reftag, _ = traverse_meta(meta, ["ipub", "reftag", 0],
                              assert_type="Str")
    prefix = ""

    # replace markdown references with latex ones
    if key == 'Link':
        target = value[-1][0]  # in older pandoc, no attributes at front
        m = re.match(r'#(.+)$', target)
        if m:
            # pandoc automatically makes labels for headings.
            label = _sanitize_label(m.group(1))
            if fmt == "latex":
                return RawInline(
                    'tex', '{0}\\{1}{{{2}}}'.format(prefix, reftag, label))
            elif fmt == "rst":
                # RawInline('rst', ":ref:``".format(label))
                # TODO link vs ref?
                return None

    # replace html style citations; <cite data-cite="cite_key"></cite>
    # TODO this does not remove any content between the start-end tags
    if key == 'RawInline' and value[0] == 'html':
        if re.match(r"^\s*</cite>\s*$", value[1]):
            return []  # remove
        match = re.match(
            r"<cite\s*data-cite\s*=\"?([^>\"]*)\"?>", value[1])
        if not match:
            return None
        key = match.group(1)
        if not key:
            return []
        if fmt == "latex":
            return RawInline('tex', "\\cite{{{0}}}".format(key))
        if fmt == "rst":
            return RawInline('rst', " :cite:`{0}` ".format(key))
            # NB citations must have space at either side to be resolved

    # replace @label style references
    if use_at_notation:
        # References may occur in a variety of places; we must process them
        # all.
        if key in ['Para', 'Plain']:
            _process_at_refs(value, fmt, use_numref)
        elif key == 'Image':
            _process_at_refs(value[-2], fmt, use_numref)
        elif key == 'Table':
            _process_at_refs(value[-5], fmt, use_numref)
        elif key == 'Span':
            _process_at_refs(value[-1], fmt, use_numref)
        elif key == 'Emph':
            _process_at_refs(value, fmt, use_numref)
        elif key == 'Strong':
            _process_at_refs(value, fmt, use_numref)

    return None


def _process_at_refs(el, fmt="latex", use_numref=True):
    """ find citation elements using @ notation
    and replace with appropriate latex tags / rst roles

    # NOTE in pandoc-xnos they repair_refs for
    # "-f markdown+autolink_bare_uris" with pandoc < 1.18
    """
    numref = "numref" if use_numref else "ref"

    deletions = []
    for i, sub_el in enumerate(el):
        if sub_el['t'] == 'Cite' and len(sub_el['c']) == 2:
            citations = sub_el['c'][0]
            # extracts the */+/! modifier in front of the Cite
            modifier = None
            if el[i-1]['t'] == 'Str':
                modifier = el[i - 1]['c'][-1]
                if modifier in ['^', '+', '!', '=']:
                    if len(el[i - 1]['c']) > 1:
                        # Cut the modifier off of the string
                        el[i-1]['c'] = el[i-1]['c'][:-1]
                    else:
                        # The element contains only the modifier; delete it
                        deletions.append(i-1)

            labels = [citation["citationId"] for citation in citations]

            if fmt == "latex":
                tag = {'+': 'cref', '^': "Cref", "!": "ref", "=": "eqref",
                       }.get(modifier, 'cite')
                if tag in ["ref", "eqref"] and len(citations) > 1:
                    tex = (
                        ", ".join(['\\{0}{{{1}}}'.format(tag, l)
                                   for l in labels[:-1]]) +
                        ' and \\{0}{{{1}}}'.format(tag, labels[-1]))
                else:
                    tex = '\\{0}{{{1}}}'.format(tag, ",".join(labels))

                el[i] = RawInline('tex', tex)

            if fmt == "rst":
                tag = {'+': numref, '^': numref, "!": "ref", "=": "eq",
                       }.get(modifier, 'cite')
                if tag == "cite":
                    rst = ' :{0}:`{1}` '.format(tag, ",".join(labels))
                    # NB citations must have space either side to be resolved
                elif len(citations) == 1:
                    rst = ':{0}:`{1}`'.format(tag, ",".join(labels))
                else:
                    rst = (
                        ",".join([':{0}:`{1}`'.format(tag, l)
                                  for l in labels[:-1]]) +
                        ' and :{0}:`{1}`'.format(tag, labels[-1]))

                el[i] = RawInline('rst', rst)

    # delete in place
    deleted = 0
    for delete in deletions:
        del el[delete - deleted]
        deleted += 1


def resolve_math(key, value, fmt, meta):
    """ see https://github.com/tomduck/pandoc-eqnos/blob/master/pandoc_eqnos.py

    Parameters
    ----------
    key: str
        the type of the pandoc object (e.g. 'Str', 'Para')
    value:
        the contents of the object (e.g. a string for 'Str', a list of
        inline elements for 'Para')
    fmt: str
        is the target output format (as supplied by the
        `format` argument of `walk`)
    meta:
        is the document's metadata

    Returns
    -------
    pandoc_object:

    """
    if key == 'Math' and len(value) == 3:

        body = value[-1]
        # mtype = value[1]
        # # e.g. {'t': 'InlineMath'} or {'t': 'DisplayMath'}
        attributes = value[0]
        label = attributes[0]
        keywords = dict(attributes[-1])

        if label and fmt == "latex":
            label_tag = "\\label{{{0}}}".format(label)
        else:
            label_tag = ""
        env = keywords.get('env', 'equation')
        numbered = '' if strtobool(
            keywords.get('numbered', 'true')) else '*'
        tex = '\\begin{{{0}{1}}}{2}{3}\\end{{{0}{1}}}'.format(
            env, numbered, body, label_tag)

        if fmt == "latex":
            return RawInline('tex', tex)
        elif fmt == "rst":
            if not label:
                return RawInline(
                    'rst',
                    '\n\n.. math::\n   :nowrap:\n\n   {0}\n\n'.format(tex))
            return RawInline(
                'rst', '\n\n.. math::\n   :nowrap:\n   :label: {0}'
                '\n\n   {1}\n\n'.format(label, tex))


def _convert_scale(string, out_units):
    match = re.compile(
        "^\\s*([0-9]+\\.?[0-9]*)([a-z\\%]*)\\s*$").match(str(string))
    if match is None:
        raise ValueError(
            "string could not be resolved as a value: {}".format(string))
    value = float(match.group(1))
    in_units = match.group(2)
    in_units = "fraction" if not in_units else in_units

    if in_units == out_units:
        return value

    convert = {
        ("%", "fraction"): lambda x: x / 100.,
        ("fraction", "%"): lambda x: x*100.
    }.get((in_units, out_units), None)

    if convert is None:
        raise ValueError("could not find a conversion for "
                         "{0} to {1}: {2}".format(in_units, out_units, string))

    return convert(value)


def resolve_figures(key, value, fmt, meta):
    """ see https://github.com/tomduck/pandoc-eqnos/

    NB: for latex fmt, to convert captions, a 'pandoc_api' key 
    is required in the metadata of the form '1.2.3.4'

    Parameters
    ----------
    key: str
        the type of the pandoc object (e.g. 'Str', 'Para')
    value:
        the contents of the object (e.g. a string for 'Str', a list of
        inline elements for 'Para')
    fmt: str
        is the target output format (as supplied by the
        `format` argument of `walk`)
    meta:
        is the document's metadata

    Returns
    -------
    pandoc_object:

    """
    api_version, _ = traverse_meta(meta, ["pandoc_api", 0],
                                   assert_type="Str")

    if api_version is None:
        api_version, _ = traverse_meta(meta, ["ipub", "pandoc_api", 0],
                                       assert_type="Str")

    if key == 'Para' and len(value) == 1 and value[0]['t'] == 'Image':
        if len(value[0]['c']) == 2:  # Unattributed, bail out
            return None
        attributes, caption_block = value[0]['c'][:2]
        path, typef = value[0]['c'][2]  # TODO is typef always 'fig:'?
        label = _sanitize_label(attributes[0])
        keywords = dict(attributes[-1])

        if fmt == "latex":

            # convert the caption to latex
            # TODO is there a better way to do this
            caption_json = None
            if compare_version('1.18', '>=') and api_version:
                caption_json = json.dumps(
                    {
                        "blocks": [{"t": "Para", "c": caption_block}],
                        "meta": meta,
                        "pandoc-api-version": [
                            int(s) for s in api_version.strip().split(".")]
                    })
            elif compare_version('1.18', '>='):
                warnings.warn("'pandoc_api' was not set in the metadata, "
                              "so cannot convert caption")
            else:  # old API
                caption_json = json.dumps(
                    [{'unMeta': {}},
                        [{"t": "Para", "c": caption_block}]])

            if caption_json is not None:
                try:
                    caption = convert_pandoc(caption_json, 'json', 'latex')
                except RuntimeError as err:
                    raise ValueError(
                        "could not convert the pandoc block containing a "
                        "caption: {}\n{}".format(caption_json, err))
            else:
                caption = ""

            options = keywords.get("placement", "")
            size = ''
            if "width" in keywords:
                width = _convert_scale(keywords['width'], "fraction")
                size = 'width={0}\\linewidth'.format(width)
            elif "height" in keywords:
                height = _convert_scale(keywords['height'], "fraction")
                size = 'height={0}\\paperheight'.format(height)

            if label:
                latex = LATEX_FIG_LABELLED.format(
                    label=label,
                    options=options,
                    path=path,
                    caption=caption,
                    size=size)
            else:
                latex = LATEX_FIG_UNLABELLED.format(
                    options=options,
                    path=path,
                    caption=caption,
                    size=size)

            return {"t": "Para", "c": [RawInline('tex', latex)]}

        elif fmt == "rst":
            # TODO rst figure, all works except convert width/height to %
            return None


def resolve_tables(key, value, fmt, meta):
    """ see https://github.com/tomduck/pandoc-tablenos

    Parameters
    ----------
    key: str
        the type of the pandoc object (e.g. 'Str', 'Para')
    value:
        the contents of the object (e.g. a string for 'Str', a list of
        inline elements for 'Para')
    fmt: str
        is the target output format (as supplied by the
        `format` argument of `walk`)
    meta:
        is the document's metadata

    Returns
    -------
    pandoc_object:

    """
    from pandocxnos import elt
    AttrTable = elt('Table', 6)

    if key == 'Table':
        if len(value) == 5:  # Unattributed, bail out
            return None
        attributes, caption = value[:2]
        label = _sanitize_label(attributes[0])

        if fmt == "latex":
            value[1] += [RawInline('tex', '\\label{{{0}}}'.format(label))]
            return [AttrTable(*value)]

        elif fmt == "rst":
            rst_label = RawInline('rst', '\n.. _`{0}`:\n\n'.format(label))
            return [{"t": "Para", "c": [rst_label]}, AttrTable(*value)]
