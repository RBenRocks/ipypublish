import subprocess
from io import TextIOWrapper, BytesIO
import re
import warnings

from distutils.version import LooseVersion
from six import string_types
from pandocfilters import elt as _elt
from nbconvert.utils.pandoc import (get_pandoc_version, check_pandoc_version,
                                    cast_bytes)


def convert_pandoc(source, fmt, to, extra_args=None, encoding='utf-8',
                   allow_stderr=False):
    """Convert an input string using pandoc.

    Pandoc converts an input string `from` a format `to` a target format.

    This is copied from nbconvert, but raises an exception if pandoc fails,
    rather than failing silently

    Parameters
    ----------
    source : string
      Input string, assumed to be valid format `from`.
    fmt : string
      The name of the input format (markdown, etc.)
    to : string
      The name of the output format (html, etc.)

    Returns
    -------
    out : str
      Output as returned by pandoc.

    Raises
    ------
    nbconvert.pandoc.PandocMissing
      If pandoc is not installed.
    RuntimeError
      If allow_stderr=False and stderr returned from pandoc is not empty

    Any error messages generated by pandoc are printed to stderr.

    """
    cmd = ['pandoc', '-f', fmt, '-t', to]
    if extra_args:
        cmd.extend(extra_args)

    # this will raise an exception that will pop us out of here
    check_pandoc_version()

    # we can safely continue
    p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    stdout, stderr = p.communicate(cast_bytes(source, encoding))
    stdout = TextIOWrapper(BytesIO(stdout), encoding, 'replace').read()
    stderr = TextIOWrapper(BytesIO(stderr), encoding, 'replace').read()
    if stderr:
        raise RuntimeError("pandoc run failed: {}".format(stderr))

    return stdout.rstrip('\n')


def compare_version(target, comparison):
    """Set docstring here.

    Parameters
    ----------
    target: str
        target version of pandoc
    comparison: str
        one of '>', '<', '<=', '>=', '=='

    Returns
    -------
    bool

    """
    # from pandocxnos import init as get_pandoc_version
    version = LooseVersion(get_pandoc_version())
    required = LooseVersion(target)
    if comparison == ">=":
        return version >= required
    elif comparison == "<=":
        return version <= required
    elif comparison == ">":
        return version > required
    elif comparison == "<":
        return version < required
    elif comparison == "==":
        return version == required
    else:
        raise ValueError("comparison not recognised: {}".format(comparison))


def get_api_version(source_json, as_str=True):
    """
    return None if not found
    if as_str=True return '1.2.3' else return [1, 2, 3]
    """
    # TODO is there a better way to get the pandoc-api-version
    api_version = None
    if compare_version('1.18', '>='):
        try:
            api_version = source_json.get("pandoc-api-version", None)
        except Exception as err:
            warnings.warn("could not extract pandoc-api-version "
                          "from source: {}".format(err))

    if api_version is not None and as_str:
        return ".".join([str(i) for i in api_version])
    return api_version


def traverse_meta(meta, keypath, return_missing=(None, None),
                  assert_type=None):
    """traverse pandoc json meta 

    Parameters
    ----------
    meta: dict
    keypath: list
        path to traverse. if the last key is an integer, 
        then return that index of a "MetaInlines"
    return_missing=None: 
        what to return if the keypath is not found
    assert_type=None: str or None
        if not None, assert the returned object has a particular pandoc type

    Returns
    -------
    pvalue: object
        the value of the pandoc node
    ptype: str
        the type of the pandoc node

    """
    final_index = None
    if isinstance(keypath[-1], int):
        final_index = keypath.pop(-1)

    for i, key in enumerate(keypath):
        if not isinstance(key, string_types):
            raise TypeError("key must be a string: {}".format(key))
        if i == 0 and key not in meta:
            return return_missing
        elif i != 0 and meta["t"] != "MetaMap":
            return return_missing
        elif i != 0 and key not in meta["c"]:
            return return_missing

        if i == 0:
            meta = meta[key]
        else:
            meta = meta["c"][key]

    if final_index is not None:
        if meta["t"] != "MetaInlines":
            return return_missing
        meta = meta["c"][final_index]

    if assert_type is not None and assert_type != meta["t"]:
        raise ValueError(
            "the metadata from {0} is {1} instead of {2}".format(
                keypath, meta["t"], assert_type
            ))

    return meta["c"], meta["t"]


def sanitize_label(label):
    """from pandoc documentation
    The citation key must begin with a letter, digit, or _,
    and may contain alphanumerics, _,
    and internal punctuation characters (:.#$%&-+?<>~/)
    """
    label = str(label).lower()
    label = re.sub("[^a-zA-Z0-9-:\\.]+", "", label)
    # TODO raise warning if changed?
    return label


def elt(eltType, numargs):  # pylint: disable=invalid-name
    """Returns Element(``*value``) to create pandoc json elements.

    This should be used in place of pandocfilters.elt().  This version
    ensures that the content is stored in a list, not a tuple.
    """
    def element(*value):  # pylint: disable=invalid-name
        """Creates an element."""
        el = _elt(eltType, numargs)(*value)
        if isinstance(el['c'], tuple):
            el['c'] = list(el['c'])  # The content should be a list, not tuple
        return el
    return element


class ElementTypes(object):
    """
    Improved version of pandocfilters element types
    """
    # Constructors for block elements

    Plain = elt('Plain', 1)
    Para = elt('Para', 1)
    CodeBlock = elt('CodeBlock', 2)
    RawBlock = elt('RawBlock', 2)
    BlockQuote = elt('BlockQuote', 1)
    OrderedList = elt('OrderedList', 2)
    BulletList = elt('BulletList', 1)
    DefinitionList = elt('DefinitionList', 1)
    Header = elt('Header', 3)
    HorizontalRule = elt('HorizontalRule', 0)
    Table = elt('Table', 5)
    AttrTable = elt('Table', 6)
    Div = elt('Div', 2)
    Null = elt('Null', 0)

    # Constructors for inline elements

    Str = elt('Str', 1)
    Emph = elt('Emph', 1)
    Strong = elt('Strong', 1)
    Strikeout = elt('Strikeout', 1)
    Superscript = elt('Superscript', 1)
    Subscript = elt('Subscript', 1)
    SmallCaps = elt('SmallCaps', 1)
    Quoted = elt('Quoted', 2)
    Cite = elt('Cite', 2)
    Code = elt('Code', 2)
    Space = elt('Space', 0)
    LineBreak = elt('LineBreak', 0)
    Math = elt('Math', 2)
    RawInline = elt('RawInline', 2)
    Link = elt('Link', 3)
    Image = (elt('Image', 2) if compare_version('1.16', '<')
             else elt('Image', 3))
    Note = elt('Note', 1)
    SoftBreak = elt('SoftBreak', 0)
    Span = elt('Span', 2)

    # Constructors for meta objects
    MetaBool = elt('MetaBool', 1)
    MetaString = elt('MetaString', 1)
    # MetaMap
    # MetaInlines
    # MetaList
    # MetaBlocks
